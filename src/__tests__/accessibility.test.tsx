import { describe, it, expect, vi } from "vitest";
import { render, screen } from "@testing-library/react";
import { renderHook } from "@testing-library/react";
import {
  useGeneratedId,
  A11yFormFieldProvider,
  useA11yFormField,
  useFocusTrap,
  useReturnFocus,
  announce,
  SkipLink,
  VisuallyHidden,
} from "../lib/accessibility";
import * as React from "react";

describe("Accessibility Utilities", () => {
  describe("useGeneratedId", () => {
    it("generates unique IDs", () => {
      const { result: result1 } = renderHook(() => useGeneratedId());
      const { result: result2 } = renderHook(() => useGeneratedId());

      expect(result1.current).toBeTruthy();
      expect(result2.current).toBeTruthy();
      expect(result1.current).not.toBe(result2.current);
    });

    it("uses provided ID when given", () => {
      const { result } = renderHook(() => useGeneratedId("custom-id"));
      expect(result.current).toBe("custom-id");
    });
  });

  describe("A11yFormFieldProvider", () => {
    function TestConsumer() {
      const field = useA11yFormField();
      return (
        <div>
          <span data-testid="id">{field.id}</span>
          <span data-testid="label-id">{field.labelId}</span>
          <span data-testid="desc-id">{field.descriptionId}</span>
          <span data-testid="error-id">{field.errorId}</span>
          <span data-testid="has-error">{field.hasError.toString()}</span>
        </div>
      );
    }

    it("provides field context", () => {
      render(
        <A11yFormFieldProvider>
          <TestConsumer />
        </A11yFormFieldProvider>,
      );

      // ID is generated by React.useId, pattern varies by implementation
      expect(screen.getByTestId("id").textContent).toBeTruthy();
      expect(screen.getByTestId("label-id")).toHaveTextContent(/-label$/);
      expect(screen.getByTestId("desc-id")).toHaveTextContent(/-description$/);
      expect(screen.getByTestId("error-id")).toHaveTextContent(/-error$/);
    });

    it("uses provided ID", () => {
      render(
        <A11yFormFieldProvider id="my-field">
          <TestConsumer />
        </A11yFormFieldProvider>,
      );

      expect(screen.getByTestId("id")).toHaveTextContent("my-field");
    });

    it("tracks error state", () => {
      render(
        <A11yFormFieldProvider hasError={true}>
          <TestConsumer />
        </A11yFormFieldProvider>,
      );

      expect(screen.getByTestId("has-error")).toHaveTextContent("true");
    });

    it("throws when used outside provider", () => {
      const consoleSpy = vi
        .spyOn(console, "error")
        .mockImplementation(() => {});

      expect(() => {
        render(<TestConsumer />);
      }).toThrow(
        "useA11yFormField must be used within a A11yFormFieldProvider",
      );

      consoleSpy.mockRestore();
    });
  });

  describe("SkipLink", () => {
    it("renders with correct href", () => {
      render(<SkipLink targetId="main-content" />);
      const link = screen.getByText("Skip to main content");
      expect(link).toHaveAttribute("href", "#main-content");
    });

    it("uses custom children", () => {
      render(<SkipLink targetId="nav">Skip to navigation</SkipLink>);
      expect(screen.getByText("Skip to navigation")).toBeInTheDocument();
    });

    it("has sr-only class by default", () => {
      render(<SkipLink targetId="main" />);
      expect(screen.getByText("Skip to main content")).toHaveClass("sr-only");
    });
  });

  describe("VisuallyHidden", () => {
    it("renders with sr-only class", () => {
      render(<VisuallyHidden>Hidden text</VisuallyHidden>);
      expect(screen.getByText("Hidden text")).toHaveClass("sr-only");
    });

    it("shows content in debug mode", () => {
      render(<VisuallyHidden debug>Debug text</VisuallyHidden>);
      expect(screen.getByText("Debug text")).not.toHaveClass("sr-only");
    });
  });

  describe("announce", () => {
    it("creates and removes announcer element", async () => {
      vi.useFakeTimers();

      announce("Test announcement");

      // Should create element
      const announcer = document.querySelector('[role="status"]');
      expect(announcer).toBeInTheDocument();
      expect(announcer).toHaveTextContent("Test announcement");

      // Should remove after delay
      vi.advanceTimersByTime(1100);
      expect(document.querySelector('[role="status"]')).not.toBeInTheDocument();

      vi.useRealTimers();
    });

    it("sets aria-live to assertive when specified", () => {
      announce("Urgent!", "assertive");

      const announcer = document.querySelector('[role="status"]');
      expect(announcer).toHaveAttribute("aria-live", "assertive");
    });
  });

  describe("useFocusTrap", () => {
    it("returns a ref", () => {
      const { result } = renderHook(() => useFocusTrap(true));
      expect(result.current).toHaveProperty("current");
    });

    it("does not trap when inactive", () => {
      const { result } = renderHook(() => useFocusTrap(false));
      expect(result.current.current).toBeNull();
    });
  });

  describe("useReturnFocus", () => {
    it("returns focus to previous element on unmount", () => {
      const button = document.createElement("button");
      document.body.appendChild(button);
      button.focus();

      const { unmount } = renderHook(() => useReturnFocus(true));

      // Focus something else
      const input = document.createElement("input");
      document.body.appendChild(input);
      input.focus();

      // Unmount should return focus
      unmount();
      expect(document.activeElement).toBe(button);

      // Cleanup
      button.remove();
      input.remove();
    });
  });
});
